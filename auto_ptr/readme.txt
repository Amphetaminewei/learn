这是一个基于template的简易智能指针demo，用来在特定情况下代替原生指针防止一些不安全和不能及时删除指针的情况发生
这个类将原生指针封装成一个对象，然后通过析构函数来delete指针
同时它禁止对象的共享，对auto_ptr的复制动作会移交地址的拥有权，同时只有一个auto_ptr指向同一块内存

auto_ptr支持类似原生指针的*和->操作，某种程度上你可以像使用原生指针那样使用它，只是加上了一些限制（比如复制）

如果你希望有一个自动析构的指针对象，并且你不需要或者想要防止多个指针指向同一块内存的情况，auto_ptr可以帮你完成这个任务

对象初始化:
    接收一个指针用来初始化内建指针，默认值为nullptr
    auto_ptr<T>demo(new T(value));

    注意这个类是用来代替原生指针的，所以不要去做那种创建原生指针后再用他创建一个auto_ptr的行为
    比如这种
        int a = 10;
        int* b = &a;
        auto_ptr<int>p(b);
    他的可怕之处我在后面有单独说明

复制和赋值：
    这个类禁止多个对象指向同一个地址，在赋值时会将右值的所有权交给左值然后将右值指针制为空
    在复制时作为参数的对象会把指针所有权交给调用构造复制构造函数的对象并将指针制空
    复制和赋值都支持对两个类型不同的智能指针进行操作，会调用其实际类型的隐式类型转换

    注意这里的复制构造函数和operator=可以对两个类型不同的auto_ptr这件事并不绝对成立，也没有经过严格的测试
    所以没有必要的话我并不推荐你这么做

getPtr():
    返回内部的指针

release()：
    返回内部指针并移除对象对指针的拥有权
    注意这里没有将指针指向的内存释放，也就是oldPointee及其继任者有义务将这块内存释放
	如果你想用这个函数来将一个智能指针置为空，而不接受其返回值，那将有一块你无法释放的内存一直存在

	int *b = a.release() 这样可以
	a.release()          这样会不能正常释放指针，因为a已经失去了指针的掌控权，但是没有一个指针出来继承这个掌控权
	                     掌控权在oldPointee手里但是你得不到他

reset(T* p = nullptr)：
    delete原本的指针并绑定一个新指针

operator->()：
    像原生指针一样返回一个T类型的原生指针

operator*()：
    像原生指针一样返回一个T类型的引用


Demo：
    Demo中进行了一些简单的测试以及演示，
    包括两个不推荐的用法演示，两个能通过编译但是也仅仅是能通过编译而且会带来十足麻烦的情况
    还有上面提到的错误初始化方式


如果你用这种创建
    int a = 10;
    int* b = &a;
    auto_ptr<int>p(b);
这种调用方式会在析构p的时候发生错误，因为这种方式实际上和智能指针的初衷是相悖的，他的初衷是用来在一些场景代替原生指针
但是这种用法都创建出原生指针了还多此一举加一个只能指针干嘛，我真是脑子抽了
这是逻辑上，客观上在p析构的之后会将b指向的内存释放掉，b就成了野指针啦，我在设计里想尽办法组织两个指针指向同一个内存结果在测试的时候脑子抽了


这件事还引出了一个思考就是，在类的设计上我屏蔽了两个智能指针指向同一块内存的可能，
但是在类型运用上，我还是无法阻止你创建一个和智能指针指向同一块内存的原生指针
如果想要智能指针除了创建外其他和原生指针没有区别，就必须能够将原生指针返回出来，这也给了你找到他实际指向地址的机会
换句话说，这也让你能够创建一个和他指向相同地址的原生指针！
在设计上我觉得能让你获取原生指针是有必要的，但是我极力不建议你创建一个诸如我在demo中创建的i,j这种指针
这样你的智能指针就失去意义啦，更可怕的是，如果那个智能指针被析构，那你的i,j就会变成可怕的怪物了 