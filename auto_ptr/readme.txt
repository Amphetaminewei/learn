这是一个基于template的简易智能指针demo，用来在特定情况下代替原生指针防止一些不安全和不能及时删除指针的情况发生
这个类将原生指针封装成一个对象，然后通过析构函数来delete指针

复制和赋值：
    这个类禁止多个对象指向同一个地址，在赋值时会将右值的所有权交给左值然后将右值指针制为空
    在复制时作为参数的对象会把指针所有权交给调用构造复制构造函数的对象并将指针制空
    复制和赋值都支持对两个类型不同的智能指针进行操作，会调用其实际类型的隐式类型转换

getPtr():
    返回内部的指针

release()：
    返回内部指针并移除对象对指针的拥有权
    注意这里名没有将指针指向的内存释放，也就是oldPointee及其继任者有义务将这块内存释放
	如果你想用这个函数来将一个智能指针置为空，而不接受其返回值，那将有一块你无法释放的内存一直存在

	int *b = a.release()这样可以
	a.release() 这样会不能正常释放指针，因为a已经失去了指针的掌控权，但是没有一个指针出来继承这个掌控权
	掌控权在oldPointee手里但是你得不到他

reset()：
    delete原本的指针并绑定一个新指针


这个类只能做一个demo描述一下思路因为实际上这样操作指针还是会有问题，其中最明显的就是在对象析构的时候会出现问题，
我在测试的时候每次调用到delete的时候都会触发一个异常，无论是析构函数还是reset函数的delete都会有这个问题emmmm
问题解决了蒽，因为用法的问题，我脑子抽了
如果你用这种调用
    int a = 10;
    int* b = &a;
    auto_ptr<int>p(b);
这种调用方式会在析构p的时候发生错误，因为这种方式实际上和智能指针的初衷是相悖的，他的初衷是用来在一些场景代替原生指针
但是这种用法都创建出原生指针了还多此一举加一个只能指针干嘛，我真是脑子抽了
这是逻辑上，客观上在p析构的之后会将b指向的内存释放掉，b就成了野指针啦，我在设计里想尽办法组织两个指针指向同一个内存结果在测试的时候脑子抽了


这件事还引出了一个问题就是，在类的设计上我屏蔽了两个智能指针指向同一块内存的可能，
但是在类型运用上，我还是无法阻止你创建一个和智能指针指向同一块内存的原生指针
如果想要智能指针除了创建外其他和原生指针没有区别，就必须能够将原生指针返回出来，这也给了你找到他实际指向地址的机会
换句话说，这也让你能够创建一个和他指向相同地址的原生指针！
在设计上我觉得能让你获取原生指针是有必要的，但是我极力不建议你创建一个诸如我在demo中创建的i,j这种指针
这样你的智能指针就失去意义啦，更可怕的是，如果那个智能指针被析构，那你的i,j就会变成可怕的怪物了