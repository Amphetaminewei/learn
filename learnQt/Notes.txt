信号槽：
    创建一个连接，在信号发出者发出特定信号时，接收者捕获特定信号并作出回应
    

自定义信号槽：
    只有继承了QObject类才具有信号槽能力
    凡是继承了QObject类都应该在第一行写上Q_OBJECT
    这个宏的展开将为我们的类提供信号槽机制、国际化机制以及 Qt 提供的不基于 C++ RTTI 的反射能力
    如果我们的Newspaper和Reader类位于 main.cpp 中，是无法得到 moc 的处理的
    signals 块所列出的，就是该类的信号
    信号就是一个个的函数名，返回值是void（因为无法获得信号的返回值也就无需返回值了），参数是该类需要让外界知道的数据
    moc会帮我们实现信号所需的函数体
    emit 的含义是发出，也就是发出newPaper()信号
    与信号函数不同，槽函数必须自己完成实现代码
    实例中的send()作用只是发出信号，来测试信号槽的工作
    在 Qt 4 中，槽函数必须放在由 slots 修饰的代码块中，并且要使用访问控制符进行访问控制


模块：
    Qt 5 模块分为 Essentials Modules(基础模块) 和 Add-on Modules(扩展模块) 两部分


MainWindow：
    普通意义上的应用程序的最顶层窗口


pro文件：
    用于告诉编译器，需要使用哪些模块
    TARGET 是生成的程序的名字
    TEMPLATE 是生成 makefile 所使用的模板，比如 app 就是编译成一个可执行程序，而 lib 则是编译成一个链接库（默认是动态链接库）
    SOURCES 和 HEADERS 顾名思义，就是项目所需要的源代码文件和头文件


QKeySequence：
    定义了许多内置快捷键，以便实现跨平台


关于action个人理解：
    我的理解里一个按钮分为三个部分，一个就是按钮本身，一个是这个按钮点击的动作，还有就是这个动作会发生的事情
    其中按钮本身是MainWindow的函数创建的，
    而按钮点击的动作也就是action，为什么不直接将按钮与信号槽连接起来呢，我觉得一方面是因为不同的模块可以绑定同一个动作，同一个动作的不同信号又可以连接不同的信号槽
    也就是 模块 → action → 信号 → 信号槽 这种模式


关于对象树：
    QObject对象由对象树的形式组织
    在构建一个新的QObject对象时可以提供要给指向父对象的指针，以便在父对象析构的同时将子对象析构
    通过这种组织方法就能将子对象创建成父对象界面中的组件与其绑定
    在创建QObject对象的同时qt会创建一个这个对象的对象树，对象树中的对象是没有顺序的
    Qt析构对象树中的对象时没有顺序，Qt保证的是当你析构对象时将其从其父对象的children()列表中删除，如果其有子对象则析构其全部子对象
    在Qt中尽可能在创建对象时就绑定他的父对象，这样可以阻止你在创建子对象之后才创建父对象，也就一定程度上可以防止子对象被析构两次导致的崩溃
    在主函数中应尽量在栈上创建对象，因为主函数会开启一个事件循环，意味着你无法及时delete
    其他时候大胆的去在堆上创建对象（但是对new的恐惧让我还是不愿意这么做）
    父子对象是为了简化动态分配的对象的管理，本来就应该是只有动态创建的对象才可以设置父对象，栈上创建的对象本来就不应该设置父对象


布局管理器：
    布局管理器提供了除了更简易的定位方式，只需要将组件加入相应的布局中他就会帮你进行自动调成
    与窗口的关系是，为窗口添加布局→为布局添加要管理的组件
    布局管理器会让你更改窗口时更改应该更改的组件大小，正如例子中的spinBox并不会因为我们拉伸窗口而被拉伸
    虽然豆子没提，但是我觉得这东西应该会有类似手动控制这种模式，毕竟有的时候我们想要的还是不和他想的一样


菜单栏和工具栏：
    MainWindow提供了menuBar和toolBar函数但是QWidget和QDialog并没有提供
    menuBar函数会返回窗口的菜单栏，如果没有菜单栏则会创建一个，所以你可以直接使用他的返回值get窗口的菜单栏
    创建菜单栏和工具栏的语法不同，因为工具栏可以有很多但是菜单栏一般只有一个，所以我们创建了第二个状态栏而且同样绑定了openAction
    状态栏是一个用来显示的组件，在代码里发现，状态栏显示什么东西是依靠的组件的action
    action设置成什么，在这个动作的时候就会在状态栏显示什么
    新建菜单时直接建一个菜单而不是菜单中的项，菜单中的项实际上就是我们的action，所以想在file菜单中加入其他项比如new，就应该为file菜单添加new这个动作
    同样对于工具栏，如果在工具栏中加入其他项则直接添加这个动作


再看action：
    action设置了绑定这个action的组件的图标，快捷键，还有状态栏的显示
    这么看的话action的作用也就明显了，以打开为例，一个桌面程序中会有很多中途径进行打开文件操作，比如菜单栏和工具栏，就像office
    但是通过不同的途径实际上执行的是同一个动作，也就是打开文件，所以只需要一个action就可以了
    然后就可以拥有同样的快捷键和状态栏显示这些
    在关于aboutMenuAndTool代码中可以看到，我们可以添加同一个项到不同的菜单和工具栏，通过对菜单栏和工具栏添加同样的action来实现
    但是，action不只是作为项用，本质上就像他的名字一样他是一个动作，在菜单栏里表现为Open按钮，点击即执行这个动作，发出信号并调用对这个信号有兴趣的对象的槽函数


对话框：
    对话窗口通常是一个顶层窗口，出现在程序最上层，用于实现短期任务或简洁的用户交互
    我们通常会设计一个类继承QDialog
    对于QDialog及其子类，如果其parent指针为NULL则这个窗口为一个顶层窗口，否则则作为其父组件的子对话框
    顶层窗口和非顶层窗口的区别在于，顶层窗口会有自己的位置而非顶层窗口和其夫组件共享位置
    对话框分为模态对话框和非模态对话框。
    所谓模态对话框，就是会阻塞同一应用程序中其它窗口的输入，例如打开文件功能
    Qt有应用级和窗口级两个级别的模态对话框，默认是应用级的
    应用级模态对话框会阻塞整个应用，而窗口级模态对话框则只阻塞与其关联的窗口
    Qt 使用QDialog::exec()实现应用程序级别的模态对话框，使用QDialog::open()实现窗口级别的模态对话框，使用QDialog::show()实现非模态对话框
    show函数不会阻塞进程，dialog是在栈上建立，所以show函数执行完毕程序继续执行里看看dialog的作用域，dialog被析构，窗口也就不存在了，所以一闪而过
    将dialog改为在堆上建立则窗口不会一闪而过，但是可以发现我们仍然能通过主窗口再打开一个dialog
    还有一个严重的问题就是，如果最堆上建立对话框对象，你会发现如同在示例中一样内存会泄露，但是如果你手动在函数的最后delete，窗口还会一闪而过
    但是如果你通过指定对话框的parent来解决这个问题，对象会在其父窗口结束的时候析构，在此之前即使你关掉了窗口也会继续占用内存
    所以示例里面通过加上dialog->setAttribute(Qt::WA_DeleteOnClose);来指定窗口关闭时的动作，即释放对象
    对于开始事件循环的应用级模态对话框，可以用QObject的deleteLater()函数在事件循环关闭时销毁对话框


对话框数据传递：
    对于使用事件循环显示的应用级模态对话框，我们可以在exec()函数后直接从对话框的对象获取数值
    exec()函数知道程序结束才会返回，也就是在程序结束的时候才能得到我们在控制台的输出
    QDialog::exec()是有返回值的，其返回值是QDialog::Accepted或者QDialog::Rejected
    exec()的返回值表示了用户点击了确定还是取消
    QDialog::show()函数会立即返回，如果我们也这么写，就不可能取得用户输入的数据，因为show返回之后实际上并没有结束这个窗口，用户也还没有输入
    所以对于非模态对话框，我们可以用信号槽机制，非模态对话框在关闭时可以调用QDialog::accept()或者QDialog::reject()或者更通用的QDialog::done()函数，所以我们可以在这里发出信号
    也就是重写一个accept函数为原本的accept加上一个发出信号的动作


QMessageBox:
    是Qt为我们提供的对话框，提供了几个基础而且常用的窗口，我们可以直接调用他来创建简单对话框
    但是QMessageBox只提供了几个简单的基础对话框，我们可以通过调用它的API来定制我们需要的窗口，就像示例中的保存窗口一样
    QMessageBox在不同的平台上，显示的窗口布局都不尽相同，也可以算是为了跨平台把蒽
    这里我们可以更清楚的看到，事件循环exec函数是有返回值的！


初看事件循环exec()：
    虽然还没开始看事件循环相关内容但是经常会用到事件循环，
    从使用中来看exec()开启了一个无线循环，保证了我们的窗口在我们窗口之前不会离开其作用域，但是，如果对于一个用堆创建的对象，也会带来一些内存问题
    因为事件循环不能让我们在窗口关闭时析构对象，如果通过设置窗口的父窗口来保证窗口析构，则在父窗口关闭之前会一直占用内存
    而且exec()函数是有返回值的，返回我们对窗口的操作，比如点击按钮之类
    同时exec()的阻塞了代码往下运行所以，只有在窗口关闭之后才会运行exec()之后的代码
    测试过程中还遇到一个问题，就是如果创建了一个QApplication并在主函数return a.exec()，但是没有创建窗口！这时测试输出正常输出但是程序一直没有结束！！！


Qt5信号槽语法：
    当信号被重载的时候，你的编译器无法确定你要连接的是哪个信号所以会报错
    这里可以改成qt4的写法或者创建函数指针来指定函数
    创建函数指针的时候可以用static_cast<>来避免类型转换的问题，当类型错误时他会给你报错
    槽函数可以比信号函数的参数少，因为实际上信号函数的参数是作为返回值用来传值的，如果槽函数的参数多则无法找到足够得参数
    有一种情况，槽函数的参数可以比信号的多，那就是槽函数的参数带有默认值
    当槽函数的参数有默认值是可以比信号函数参数多，因为信号函数不必提供那个参数，
    但是不能使用函数指针，参数默认值只能使用在直接地函数调用中。当使用函数指针取其地址的时候，默认参数是不可见的
    所以如果还不用qt4的写法的话，你需要使用lambda表达式来代替槽函数


文件对话框：
    本质上和之前的对话框都一样，不一样的是我将用文件对话框来实现保存，然后实现一个简单的文本编辑器
    写的过程中想到的问题：
        菜单栏和工具栏在创建的时候都没有指明他的父对象，那这个对象会在什么时候析构呢
        猜测由于action指定了父对象，使用这个action的组件会在action指定的父对象析构时被析构
        这里将文本编辑框作为了成员，那是应该尽可能将组件作为成员呢，还是说不需要在构造函数之外调用的组件尽可能不作为成员呢
        实现之后还有就是文本编码问题，这里的编码用的是Unicode编码所以，打开这个文件的话会出乱码，因为这个文本时utf-8的
    实现时候我们做出了一个简单的文本编辑程序但是，我们的程序中没有检查打开的是不是文本文件，当然微软会帮我们检查时限定只能搜索txt，起码在win10是这样的
    而且我们使用了QTextStream::readAll()直接读取文件所有内容，如果这个文件有 100M，程序会立刻死掉
    对了还有编码问题，读取utf-8编码的文件会乱码的


事件：
    事件（event）是由系统或者 Qt 本身在不同的时刻发出的，比如于鼠标点击，键盘输入这种，是事件驱动程序设计的基础概念
    事件驱动使我们的程序的执行不再是现行的，而是由一个个的事件驱动执行，没有事件，程序就阻塞在那里，等待事件
    在Qt中，事件与信号槽类似，但是不能互相代替
    如果我们使用组件，我们关心信号槽，如果我们自定义组件，我们要关心的是事件
    Qt中所有的事件类都继承自QEvent
    QWidget中，定义了很多事件处理的回调函数，这些函数都是 protected virtual 的，我们可以通过继承来在子类中重新实现这些函数
    事件发生时，Qt 将创建一个事件对象。Qt 中所有事件类都继承于QEvent，在事件对象创建完毕后，Qt 将这个事件对象传递给QObject的event()函数
    event()函数并不直接处理事件，而是按照事件对象的类型分派给特定的事件处理函数（event handler）
    可以看到事件和信号槽是由本质区别的，信号槽联系的是你的组件发出的信号和处理这个信号的槽函数，而事件是对于一个组件，你鼠标键盘等进行的动作，是由系统捕捉的
    例如鼠标点击菜单，点击本身是一个事件，这个事件发送一个信号，也就是我们在程序窗口中的任何动作都是事件，然后系统会对这些动作进行回应
    这些事件也会发出信号，所以可以由槽来捕捉这些信号并且由槽函数做出动作
    当重写事件回调函数时，时刻注意是否需要通过调用父类的同名函数来确保原有实现仍能进行
    在示例中，我们重载了mousePressEvent事件函数，然后我们发现，点击左键的话，我们的信号槽就不工作了！
    在点击左键的时候如果调用其父类的mousePressEvent函数则可以，证明了clicked信号是由事件mousePressEvent发出的
    我们可以把 Qt 的事件传递看成链状：如果子类没有处理这个事件，就会继续向其父类传递
    Qt 的事件对象有两个函数：accept()和ignore()，前者告诉Qt这个类的事件处理函数想要处理这个事件；后者则告诉 Qt，这个类的事件处理函数不想要处理这个事件
    如果一个事件处理函数调用了一个事件对象的accept()函数，这个事件就不会被继续传播给其父组件；如果它调用了事件的ignore()函数，Qt 会从其父组件中寻找另外的接受者
    在事件处理函数中，可以使用isAccepted()来查询这个事件是不是已经被接收了
    也就是说，如果不在你自己重载的事件函数中显示声明不接收事件，那事件将会被这个函数接受，但是这个事件没有发出clicked信号，所以这个信号槽永远不会被触发
    而ignore()说明我们想让事件继续传播，事件会继续向其父类传播
    在一个特殊的情形下，我们必须使用accept()和ignore()函数，那就是窗口关闭的事件
    对于窗口关闭QCloseEvent事件，调用accept()意味着 Qt 会停止事件的传播，窗口关闭；调用ignore()则意味着事件继续传播，即阻止窗口关闭
    我们在之前的文本编辑器上，重载了closeEvent函数，并增加了一个信号槽连接，将文本的文本更改设为信号，槽则为一个lambda表达式，作用时将是否更改的值改为ture
    在这个重载的closeEvent函数中进行了判断，如果程序更改，询问是否关闭，是的话继续关闭接受事件，然后窗口关闭，否的话将通过将事件传递而实现阻止窗口关闭


event()函数：
    event()函数并不直接处理事件，而是将这些事件对象按照它们不同的类型，分发给不同的事件处理器（event handler）
    如果你希望在事件分发之前做一些操作，就可以重写这个event()函数了
    函数返回值是 bool 类型。如果传入的事件已被识别并且处理，则需要返回 true，否则返回 false
    如果返回值是 true，并且，该事件对象设置了accept()，那么 Qt 会认为这个事件已经处理完毕，不会再将这个事件发送给其它对象，而是会继续处理事件队列中的下一事件
    注意，在event()函数中，调用事件对象的accept()和ignore()函数是没有作用的，不会影响到事件的传播
    我们处理过自己感兴趣的事件之后，可以直接返回 true，表示我们已经对此事件进行了处理
    对于其它我们不关心的事件，则需要调用父类的event()函数继续转发，否则这个组件就只能处理我们定义的事件了
    event()函数对事件做判断，之后不同的事件会调用不同的事件处理函数，也就是分发给事件处理器
    同样我们可以通过重写event()函数来屏蔽掉某些事件，比如鼠标右键（判断事件类型是不是鼠标右击，是的话直接返回ture，否则调用父类同名函数）
    由于event()函数是 protected 的，因此，需要继承已有类，如果要拦截这些事件的组件很多，就需要重写很多个event()函数


最近感觉写的代码有点多，看的有点慢，后面可能尽可能少写一些示范，除非一些有意思的东西


事件过滤器：
    QObject有一个eventFilter()函数，用于建立事件过滤器
    它会检查接收到的事件，如果这个事件是我们感兴趣的类型，就进行我们自己的处理；如果不是，就继续转发
    事件过滤器的调用时间是目标对象（也就是参数里面的watched对象）接收到事件对象之前
    这个函数返回一个 bool 类型，如果你想将参数 event 过滤出来，比如，不想让它继续转发，就返回 true，否则返回 false
    任意QObject都可以作为事件过滤器，但是如果你没有重写，他默认什么都不会过滤
    安装过滤器需要调用QObject::installEventFilter()函数，已经存在的过滤器则可以通过QObject::removeEventFilter()函数移除
    nstallEventFilter()函数是QObject的函数，QApplication或者QCoreApplication对象都是QObject的子类，因此，我们可以向QApplication或者QCoreApplication添加事件过滤器
    也就是我们可以对整个应用程序，设置同一个事件过滤器，但是这样会严重影响程序分发事件的效率
    如果你在事件过滤器中 delete 了某个接收组件，务必将函数返回值设为 true，否则，Qt 还是会将事件分发给这个接收组件，从而导致程序崩溃
    事件过滤器和被安装过滤器的组件必须在同一线程，否则，过滤器将不起作用
    如果在安装过滤器之后，这两个组件到了不同的线程，那么，只有等到二者重新回到同一线程的时候过滤器才会有效


事件总结：
    Qt为各种事件分别设计了事件处理函数，然后通过event()函数对事件进行分发，
    重写event()来实现事件控制会带来两个问题，一个是你必须继承一个组件的类，还有就是那些组件仍然会看到这个事件即使你让他不做出回应
    如果使用installEventFilter()函数给一个对象安装事件过滤器，那么该事件过滤器只对该对象有效，只有这个对象的事件需要先传递给事件过滤器的eventFilter()函数进行过滤，其它对象不受影响
    全局事件过滤器被第一个调用，之后是该对象上面的事件过滤器，其次是event()函数，最后是特定的事件处理函数
    事件处理的五个层次：重写事件处理函数、重写event()函数、为对象安装事件过滤器，为application对象安装事件过滤器、重写QCoreApplication::notify()函数
    QCoreApplication::notify()函数，和全局事件过滤器一样提供完全控制，并且不受线程的限制。但是全局范围内只能有一个被使用


自定义事件：
    主要原因是，事件的分发既可以是同步的，又可以是异步的，而函数的调用或者说是槽的回调总是同步的，而且事件可以使用过滤器
    自定义事件，你需要继承QEvent，而其中最重要的是，它提供一个QEvent::Type类型的参数
    QEvent::Type是QEvent定义的一个枚举，需要注意的是，我们的自定义事件类型不能和已经存在的 type 值重复，否则会有不可预料的错误发生
    Qt 提供了一个函数：registerEventType()，用于自定义事件的注册，函数接受一个 int 值，其默认值是 -1；函数返回值是向系统注册的新的 Type 类型的值
    如果 hint 是合法的，也就是说这个 hint 不会发生任何覆盖（系统的以及其它自定义事件的），则会直接返回这个值；否则，系统会自动分配一个合法值并返回
    Qt提供了两种方式发送自定义的事件
    QCoreApplication::sendEvent(QObject *receiver, QEvent *event);可以直接将event事件发送给receiver接受者，函数返回值是事件处理函数的返回值，所以通常在栈上创建对象
    static void QCoreApplication::postEvent(QObject *receiver, QEvent *event);将事件和事件接收者一同发送到事件处理队列，不等待事件处理立刻返回
    因为 post 事件队列会持有事件对象，并且在其 post 的时候将其 delete 掉，因此，我们必须在堆上创建event对象，而且在对象被发送之后试图访问event对象会出现问题
    因为这样的动作无异于在试图访问一个已经被delete的对象
    自定义事件处理器和之前的没啥区别，我们可以重写QObject::customEvent()函数，或者直接在event（）中重写


Qt 绘制系统简介：
    Qt 的绘图系统允许使用相同的 API 在屏幕和其它打印设备上进行绘制，整个绘图系统基于QPainter，QPainterDevice和QPaintEngine三个类
    我们可以把QPainter理解成画笔；把QPaintDevice理解成使用画笔的地方，比如纸张、屏幕，为了统一使用一种画笔，我们设计了QPaintEngine类
    Qt 的绘图系统实际上是，使用QPainter在QPainterDevice上进行绘制，它们之间使用QPaintEngine进行通讯
    我的理解是Qt提供了一个绘图系统来让用户使用，在这个组件中你可以自己绘制你想要的图形
    有个问题，我尝试在我的主窗口中添加一个画布并且将其放置在主窗口中央，然后就出现了可怕的事情了，如果我不将画布在堆上构建，他就失踪了emmmm
    也是组件的一种，然后这个组件让你可以在上面自己画UI，我是这么认为的蒽
    好吧和组件不一样，它是一个状态机


今天白天给老妈当司机，就看这么多了蒽


画刷和画笔：
    画刷用QBursh描述多用来做填充，画笔用QPen描述多用来描绘边框
    QBrush定义了QPainter的填充模式，具有样式、颜色、渐变以及纹理等属性
    QPen定义了用于QPainter应该怎样画线或者轮廓线。画笔具有样式、宽度、画刷、笔帽样式和连接样式等属性


反走样：
    直线和多边形的边界是连续的，而光栅则是由离散的点组成，在光栅显示设备上表现直线、多边形等，必须在离散位置采样
    由于采样不充分重建后造成的信息失真，就叫走样；用于减少或消除这种效果的技术，就称为反走样，反走样是图形学中的重要概念，用以防止通常所说的“锯齿”现象的出现
    可能这就是在游戏里常见的抗锯齿吧emmm
    反走样很难控制到1像素，因为反走样需要一种近似色来代替原像素的颜色，这样一来就会显得模糊而圆滑


渐变：
    Qt 提供了三种渐变：线性渐变（QLinearGradient）、辐射渐变（QRadialGradient）和角度渐变（QConicalGradient）
    

坐标系统：
    坐标系统是由QPainter控制的
    QPaintDevice的子类有QWidget、QPixmap、QPicture、QImage和QPrinter等，也就是我们常用的窗口这些，都可以作为画板？
    由于QPaintDeice是进行绘制的对象，因此，所谓坐标系统，也就是QPaintDevice上面的坐标
    默认坐标系统位于设备的左上角，也就是坐标原点 (0, 0)，x 轴方向向右；y 轴方向向下
    方格的焦点定义了坐标，也就是说，像素 (x, y) 的中心位置其实是在 (x + 0.5, y + 0.5) 的位置上
    我们使用一个像素的画笔进行绘制，可以看到，每一个绘制像素都是以坐标点为中心的矩形，但是注意，这是坐标的逻辑表示，实际绘制则与此不同
    当绘制大于1个像素时，情况比较复杂：如果绘制像素是偶数，则实际绘制会包裹住逻辑坐标值；如果是奇数，则是包裹住逻辑坐标值，再加上右下角一个像素的偏移
    如果实际绘制是偶数像素，则会将逻辑坐标值夹在相等的两部分像素之间；如果是奇数，则会在右下方多出一个像素
    对于反走样，实际绘制会包裹住逻辑坐标值，也就是多出几个像素点，来让线变得圆润，然后用渐变颜色来掩饰这里加了像素点
    QPainter是一个状态机，所以Qt提供了两个函数来保存当前状态和恢复上一个保存的状态，save()就是保存下当前状态；restore()则恢复上一次保存的结果
    Qt 提供了四种坐标变换：平移 translate，旋转 rotate，缩放 scale 和扭曲 shear
    Qt 的坐标分为逻辑坐标和物理坐标，在我们绘制时，提供给QPainter的都是逻辑坐标，之前我们看到的坐标变换，也是针对逻辑坐标的
    所谓物理坐标，就是绘制底层QPaintDevice的坐标
    Qt 使用 viewport-window 机制将我们提供的逻辑坐标转换成绘制设备使用的物理坐标，方法是，在逻辑坐标和物理坐标之间提供一层“窗口”坐标
    我们传给QPainter的是逻辑坐标（也称为世界坐标），逻辑坐标可以通过变换矩阵转换成窗口坐标，窗口坐标通过 window-viewport 转换成物理坐标（也就是设备坐标）

    好吧我傻了，涉及到图形学的东西就完全看不懂了，果然还是得慢点看消化一下了，准备明天重看一下坐标系统

坐标系统：
    如果我们的窗口是400 x 400的，我们将窗口坐标设置成200 x 200，相当于给坐标系的所有单位乘以2，现在一个单位长度相当于以前两个
    反之如果设置成100 x 100则现在的一个单位相当于以前的0.5个，可以通过这个来实现自动缩放
    窗口地址如果不变，只有物理地址改变的话，物理坐标增大一倍，我们绘制的图像的单位长度也就变成原来的一倍


绘制设备：
    QPainter可以在任何QPaintDevice的子类上进行绘制
    QPixmap继承了QPaintDevice，因此，你可以使用QPainter直接在上面绘制图形
    使用QPainter::drawPixmap()函数可以把这个文件绘制到一个QLabel、QPushButton或者其他的设备上面
    QPixmap和系统提供的原生绘图引擎息息相关，在不同的操作系统平台下，QPixmap的显示可能会有所差别
    QPixmap提供了静态的grabWidget()和grabWindow()函数，用于将自身图像绘制到目标上
    为了表示一种颜色，我们也会使用二进制，比如我们要表示 8 种颜色，需要用 3 个二进制位，这时我们就说色深是 3
    QBitmap色深固定为1 ，所以实际上是只有黑白两色的图像数据，由于QBitmap色深小，因此只占用很少的存储空间，所以适合做光标文件和笔刷
    QPixmap使用底层平台的绘制系统进行绘制，无法提供像素级别的操作，
    而QImage则是使用独立于硬件的绘制系统，实际上是自己绘制自己，因此提供了像素级别的操作，并且能够在不同系统之上提供一个一致的显示形式
    QImage与QPixmap相比，最大的优势在于能够进行像素级别的操作,你可以把QImage想象成一个 RGB 颜色的二维数组，记录了每一像素的颜色
    QPicture使用系统分辨率，并且可以调整QPainter来消除不同设备之间的显示差异
    如果我们要记录下QPainter的命令，首先要使用QPainter::begin()函数，将QPicture实例作为参数传递进去，以便告诉系统开始记录，记录完毕后使用QPainter::end()命令终止
    

Graphics View Framework：
    Graphics View 提供了一种接口，用于管理大量自定义的 2D 图形元素，并与之进行交互；还提供了用于将这些元素进行可视化显示的观察组件，并支持缩放和旋转
    Graphics View 框架包含了一套完整的事件体系，可以用于与场景中的元素进行双精度的交互
    Graphics View 是一个基于元素（item）的 MV 架构的框架，它可以分成三个部分：元素 item、场景 scene 和视图 view
    基于元素的意思是，它的每一个组件都是一个独立的元素
    使用QPainter绘图，大多是采用一种面向过程的描述方式：首先使用drawLine()画一条直线，然后使用drawPolygon()画一个多边形
    对于 Graphics View，相同的过程可以是，首先创建一个场景（scene），然后创建一个直线对象和一个多边形对象，再使用场景的add()函数，
    将直线和多边形添加到场景中，最后通过视图进行观察，就可以看到了
    MV 架构的意思是，Graphics View 提供一个 model 和一个 view（正如 MVC 架构，只不过 MV 架构少了 C 这么一个组件）
    所谓模型（model）就是我们添加的种种对象；所谓视图（view）就是我们观察这些对象的视口
    Graphics View 提供了QGraphicsScene作为场景，即是允许我们添加图形的空间，相当于整个世界
    QGraphicsView作为视口，也就是我们的观察窗口，相当于照相机的取景框，这个取景框可以覆盖整个场景，也可以是场景的一部分
    QGraphicsItem作为图形元件，以便添加到场景中去，Qt 内置了很多图形，比如直线、多边形等，它们都是继承自QGraphicsItem
    QGraphicsScene不是QWidget的子类
    本质上来说，GVF 只是一个绘图系统
    QGraphicsScene的sceneRect属性供QGraphicsView确定视图默认的滚动条区域，并且协助QGraphicsScene管理元素索引（但是我没看懂


贪吃蛇：
    选择 Graphics View Framework 作为核心框架
    我们需要一个QGraphicsScene，作为游戏发生的舞台；一个QGraphicsView，作为观察游戏舞台的组件；以及若干元素，用于表示游戏对象，比如蛇、食物以及障碍物等
    为了以后的实现方便（比如，我们希望向工具栏添加按钮等），我们不会直接以QGraphicsView作为顶层窗口，而是将其添加到一个主窗口上，也就是在MainWindow上添加
    QTimer::singleShot简单来说，它的作用是，在 msec 毫秒之后，调用 receiver 的 member 槽函数,也就是说，它的作用是方便使用，无需重写timerEvent()函数或者是创建一个局部的QTimer对象
    在我们的例子中，我们需要在视图绘制完毕后才去改变大小（视图绘制当然是在paintEvent()事件中），因此我们需要在下一次事件循环中调用adjustViewSize()函数
    我们需要在视图绘制完毕后才去改变大小（视图绘制当然是在paintEvent()事件中），因此我们需要在下一次事件循环中调用adjustViewSize()函数

好吧我折腾一下午就一个框架，还没折腾好，明天亲爱的过生日休息一天蒽

贪吃蛇：
    QTimer的处理是将其放到事件列表中，等到下一次事件循环开始时去调用这个函数。那么，QTimer::signleShot(0, ...)意思是，在下一次事件循环开始时，立刻调用指定的槽函数
    Graphics View Framework 为每一个元素维护三个不同的坐标系：场景坐标，元素自己的坐标以及其相对于父组件的坐标
    我们的地图是建立在QGraphicsScene的基础之上的，所以，里面的对象应该是QGraphicsItem实例
    通常，我们会把所有的图形元素（这里便是游戏中需要的对象，例如蛇、食物等）设计为QGraphicsItem的子类，在这个类中添加绘制自身的代码以及动画逻辑
    在我们的游戏中，应该有三个对象：蛇 Snake、食物 Food 以及墙 Wall
    按照接口约束，QGraphicsItem的子类需要重写至少两个函数：boundingRect()和paint()
    boundingRect()返回一个用于包裹住图形元素的矩形，也就是这个图形元素的范围，需要注意的是，这个矩形必须能够完全包含图形元素。所谓“完全包含”，意思是，在图形元素有动画的时候，这个矩形也必须将整个图形元素包含进去
    paint()的作用是使用QPainter将图形元素绘制出来
    setData()函数是我们之后要用到的，类似于散列一样的键值对的形式
    QPainter::save()和QPainter::restore()两个函数，用于保存画笔状态
    shape()也是一个虚函数，返回的是元素实际的路径，所谓路径，可以理解成元素的矢量轮廓线，就是QPainterPath所表示的，然后通过paint()绘制出来
    GameController的工作是，初始化场景中的游戏对象，开始游戏循环，游戏循环通常使用定时器实现，因为应用程序不仅仅是一个游戏循环，还需要响应其它事件，比如游戏者的鼠标键盘操作
    GVF 中，每一帧都应该调用一个称为advance()的函数
    QGraphicsScene::advance()会调用场景中每一个元素自己的advance()函数，所以，如果图形元素需要做什么事，必须重写QGraphicsItem的advance()，然后在游戏循环中调用这个函数
    我们在蛇对象中增加一个用于代表蛇身体长度的growing变量：当growing为正数时，蛇的身体增加一格；当growing为负数时，蛇的身体减少一格
    advance()函数用于编码移动部分，这个函数会在一秒内调用 30 次（这是我们在GameController的定时器中决定的）
    QPointF在浮点精度上表征平面上的点，QRect返回一个矩形对象
    Food的boundingRect()要大于其实际值，却不影响我们的游戏逻辑判断，这就是原因：因为我们使用的是Qt::IntersectsItemShape判断检测，这与boundingRect()无关
    由于我们不希望只因为键盘事件而继承QGprahicsScene，而且我们希望做一个事件分离让场景和控制分离开,所以我们不选择继承而是为场景添加事件过滤器来控制键盘事件
    由于添加了菜单栏后窗口大小被更改了，所以我更改了蛇的移动函数将滚动条右侧和下侧隐藏掉的部分舍弃
    然后我准备添加一个边框，也就是墙

    简单总结一下吧，本来想要写成完全体的，现在墙只是花了个边框，还不是实际意义上的墙，这段时间一地鸡毛有点没时间管这个，可能后面有时间会去完善一下
    整个程序在一个场景中绘制出来的，通过一个控制器来管理蛇，食物和墙对象，并且通过这个控制器来管理他们之间的交互和他们的运动
    创建了蛇，食物和墙三种对象，他们控制了对象的绘制形状和位置，以及对象的运动逻辑
    原本是想好好完善完善程序再好好总结一下的，但是这几天事太多了太烦了，哎