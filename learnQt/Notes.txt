信号槽：
    创建一个连接，在信号发出者发出特定信号时，接收者捕获特定信号并作出回应
    

自定义信号槽：
    只有继承了QObject类才具有信号槽能力
    凡是继承了QObject类都应该在第一行写上Q_OBJECT
    这个宏的展开将为我们的类提供信号槽机制、国际化机制以及 Qt 提供的不基于 C++ RTTI 的反射能力
    如果我们的Newspaper和Reader类位于 main.cpp 中，是无法得到 moc 的处理的
    signals 块所列出的，就是该类的信号
    信号就是一个个的函数名，返回值是void（因为无法获得信号的返回值也就无需返回值了），参数是该类需要让外界知道的数据
    moc会帮我们实现信号所需的函数体
    emit 的含义是发出，也就是发出newPaper()信号
    与信号函数不同，槽函数必须自己完成实现代码
    实例中的send()作用只是发出信号，来测试信号槽的工作
    在 Qt 4 中，槽函数必须放在由 slots 修饰的代码块中，并且要使用访问控制符进行访问控制


模块：
    Qt 5 模块分为 Essentials Modules(基础模块) 和 Add-on Modules(扩展模块) 两部分


MainWindow：
    普通意义上的应用程序的最顶层窗口


pro文件：
    用于告诉编译器，需要使用哪些模块
    TARGET 是生成的程序的名字
    TEMPLATE 是生成 makefile 所使用的模板，比如 app 就是编译成一个可执行程序，而 lib 则是编译成一个链接库（默认是动态链接库）
    SOURCES 和 HEADERS 顾名思义，就是项目所需要的源代码文件和头文件


QKeySequence：
    定义了许多内置快捷键，以便实现跨平台


关于action个人理解：
    我的理解里一个按钮分为三个部分，一个就是按钮本身，一个是这个按钮点击的动作，还有就是这个动作会发生的事情
    其中按钮本身是MainWindow的函数创建的，
    而按钮点击的动作也就是action，为什么不直接将按钮与信号槽连接起来呢，我觉得一方面是因为不同的模块可以绑定同一个动作，同一个动作的不同信号又可以连接不同的信号槽
    也就是 模块 → action → 信号 → 信号槽 这种模式