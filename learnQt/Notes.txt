信号槽：
    创建一个连接，在信号发出者发出特定信号时，接收者捕获特定信号并作出回应
    

自定义信号槽：
    只有继承了QObject类才具有信号槽能力
    凡是继承了QObject类都应该在第一行写上Q_OBJECT
    这个宏的展开将为我们的类提供信号槽机制、国际化机制以及 Qt 提供的不基于 C++ RTTI 的反射能力
    如果我们的Newspaper和Reader类位于 main.cpp 中，是无法得到 moc 的处理的
    signals 块所列出的，就是该类的信号
    信号就是一个个的函数名，返回值是void（因为无法获得信号的返回值也就无需返回值了），参数是该类需要让外界知道的数据
    moc会帮我们实现信号所需的函数体
    emit 的含义是发出，也就是发出newPaper()信号
    与信号函数不同，槽函数必须自己完成实现代码
    实例中的send()作用只是发出信号，来测试信号槽的工作
    在 Qt 4 中，槽函数必须放在由 slots 修饰的代码块中，并且要使用访问控制符进行访问控制


模块：
    Qt 5 模块分为 Essentials Modules(基础模块) 和 Add-on Modules(扩展模块) 两部分


MainWindow：
    普通意义上的应用程序的最顶层窗口


pro文件：
    用于告诉编译器，需要使用哪些模块
    TARGET 是生成的程序的名字
    TEMPLATE 是生成 makefile 所使用的模板，比如 app 就是编译成一个可执行程序，而 lib 则是编译成一个链接库（默认是动态链接库）
    SOURCES 和 HEADERS 顾名思义，就是项目所需要的源代码文件和头文件


QKeySequence：
    定义了许多内置快捷键，以便实现跨平台


关于action个人理解：
    我的理解里一个按钮分为三个部分，一个就是按钮本身，一个是这个按钮点击的动作，还有就是这个动作会发生的事情
    其中按钮本身是MainWindow的函数创建的，
    而按钮点击的动作也就是action，为什么不直接将按钮与信号槽连接起来呢，我觉得一方面是因为不同的模块可以绑定同一个动作，同一个动作的不同信号又可以连接不同的信号槽
    也就是 模块 → action → 信号 → 信号槽 这种模式


关于对象树：
    QObject对象由对象树的形式组织
    在构建一个新的QObject对象时可以提供要给指向父对象的指针，以便在父对象析构的同时将子对象析构
    通过这种组织方法就能将子对象创建成父对象界面中的组件与其绑定
    在创建QObject对象的同时qt会创建一个这个对象的对象树，对象树中的对象是没有顺序的
    Qt析构对象树中的对象时没有顺序，Qt保证的是当你析构对象时将其从其父对象的children()列表中删除，如果其有子对象则析构其全部子对象
    在Qt中尽可能在创建对象时就绑定他的父对象，这样可以阻止你在创建子对象之后才创建父对象，也就一定程度上可以防止子对象被析构两次导致的崩溃
    在主函数中应尽量在栈上创建对象，因为主函数会开启一个事件循环，意味着你无法及时delete
    其他时候大胆的去在堆上创建对象（但是对new的恐惧让我还是不愿意这么做）
    父子对象是为了简化动态分配的对象的管理，本来就应该是只有动态创建的对象才可以设置父对象，栈上创建的对象本来就不应该设置父对象


布局管理器：
    布局管理器提供了除了更简易的定位方式，只需要将组件加入相应的布局中他就会帮你进行自动调成
    与窗口的关系是，为窗口添加布局→为布局添加要管理的组件
    布局管理器会让你更改窗口时更改应该更改的组件大小，正如例子中的spinBox并不会因为我们拉伸窗口而被拉伸
    虽然豆子没提，但是我觉得这东西应该会有类似手动控制这种模式，毕竟有的时候我们想要的还是不和他想的一样


菜单栏和工具栏：
    MainWindow提供了menuBar和toolBar函数但是QWidget和QDialog并没有提供
    menuBar函数会返回窗口的菜单栏，如果没有菜单栏则会创建一个，所以你可以直接使用他的返回值get窗口的菜单栏
    创建菜单栏和工具栏的语法不同，因为工具栏可以有很多但是菜单栏一般只有一个，所以我们创建了第二个状态栏而且同样绑定了openAction
    状态栏是一个用来显示的组件，在代码里发现，状态栏显示什么东西是依靠的组件的action
    action设置成什么，在这个动作的时候就会在状态栏显示什么
    新建菜单时直接建一个菜单而不是菜单中的项，菜单中的项实际上就是我们的action，所以想在file菜单中加入其他项比如new，就应该为file菜单添加new这个动作
    同样对于工具栏，如果在工具栏中加入其他项则直接添加这个动作


再看action：
    action设置了绑定这个action的组件的图标，快捷键，还有状态栏的显示
    这么看的话action的作用也就明显了，以打开为例，一个桌面程序中会有很多中途径进行打开文件操作，比如菜单栏和工具栏，就像office
    但是通过不同的途径实际上执行的是同一个动作，也就是打开文件，所以只需要一个action就可以了
    然后就可以拥有同样的快捷键和状态栏显示这些
    在关于aboutMenuAndTool代码中可以看到，我们可以添加同一个项到不同的菜单和工具栏，通过对菜单栏和工具栏添加同样的action来实现
    但是，action不只是作为项用，本质上就像他的名字一样他是一个动作，在菜单栏里表现为Open按钮，点击即执行这个动作，发出信号并调用对这个信号有兴趣的对象的槽函数