信号槽：
    创建一个连接，在信号发出者发出特定信号时，接收者捕获特定信号并作出回应
    

自定义信号槽：
    只有继承了QObject类才具有信号槽能力
    凡是继承了QObject类都应该在第一行写上Q_OBJECT
    这个宏的展开将为我们的类提供信号槽机制、国际化机制以及 Qt 提供的不基于 C++ RTTI 的反射能力
    如果我们的Newspaper和Reader类位于 main.cpp 中，是无法得到 moc 的处理的
    signals 块所列出的，就是该类的信号
    信号就是一个个的函数名，返回值是void（因为无法获得信号的返回值也就无需返回值了），参数是该类需要让外界知道的数据
    moc会帮我们实现信号所需的函数体
    emit 的含义是发出，也就是发出newPaper()信号
    与信号函数不同，槽函数必须自己完成实现代码
    实例中的send()作用只是发出信号，来测试信号槽的工作
    在 Qt 4 中，槽函数必须放在由 slots 修饰的代码块中，并且要使用访问控制符进行访问控制


模块：
    Qt 5 模块分为 Essentials Modules(基础模块) 和 Add-on Modules(扩展模块) 两部分


MainWindow：
    普通意义上的应用程序的最顶层窗口


pro文件：
    用于告诉编译器，需要使用哪些模块
    TARGET 是生成的程序的名字
    TEMPLATE 是生成 makefile 所使用的模板，比如 app 就是编译成一个可执行程序，而 lib 则是编译成一个链接库（默认是动态链接库）
    SOURCES 和 HEADERS 顾名思义，就是项目所需要的源代码文件和头文件


QKeySequence：
    定义了许多内置快捷键，以便实现跨平台


关于action个人理解：
    我的理解里一个按钮分为三个部分，一个就是按钮本身，一个是这个按钮点击的动作，还有就是这个动作会发生的事情
    其中按钮本身是MainWindow的函数创建的，
    而按钮点击的动作也就是action，为什么不直接将按钮与信号槽连接起来呢，我觉得一方面是因为不同的模块可以绑定同一个动作，同一个动作的不同信号又可以连接不同的信号槽
    也就是 模块 → action → 信号 → 信号槽 这种模式


关于对象树：
    QObject对象由对象树的形式组织
    在构建一个新的QObject对象时可以提供要给指向父对象的指针，以便在父对象析构的同时将子对象析构
    通过这种组织方法就能将子对象创建成父对象界面中的组件与其绑定
    在创建QObject对象的同时qt会创建一个这个对象的对象树，对象树中的对象是没有顺序的
    Qt析构对象树中的对象时没有顺序，Qt保证的是当你析构对象时将其从其父对象的children()列表中删除，如果其有子对象则析构其全部子对象
    在Qt中尽可能在创建对象时就绑定他的父对象，这样可以阻止你在创建子对象之后才创建父对象，也就一定程度上可以防止子对象被析构两次导致的崩溃
    在主函数中应尽量在栈上创建对象，因为主函数会开启一个事件循环，意味着你无法及时delete
    其他时候大胆的去在堆上创建对象（但是对new的恐惧让我还是不愿意这么做）
    父子对象是为了简化动态分配的对象的管理，本来就应该是只有动态创建的对象才可以设置父对象，栈上创建的对象本来就不应该设置父对象


布局管理器：
    布局管理器提供了除了更简易的定位方式，只需要将组件加入相应的布局中他就会帮你进行自动调成
    与窗口的关系是，为窗口添加布局→为布局添加要管理的组件
    布局管理器会让你更改窗口时更改应该更改的组件大小，正如例子中的spinBox并不会因为我们拉伸窗口而被拉伸
    虽然豆子没提，但是我觉得这东西应该会有类似手动控制这种模式，毕竟有的时候我们想要的还是不和他想的一样


菜单栏和工具栏：
    MainWindow提供了menuBar和toolBar函数但是QWidget和QDialog并没有提供
    menuBar函数会返回窗口的菜单栏，如果没有菜单栏则会创建一个，所以你可以直接使用他的返回值get窗口的菜单栏
    创建菜单栏和工具栏的语法不同，因为工具栏可以有很多但是菜单栏一般只有一个，所以我们创建了第二个状态栏而且同样绑定了openAction
    状态栏是一个用来显示的组件，在代码里发现，状态栏显示什么东西是依靠的组件的action
    action设置成什么，在这个动作的时候就会在状态栏显示什么
    新建菜单时直接建一个菜单而不是菜单中的项，菜单中的项实际上就是我们的action，所以想在file菜单中加入其他项比如new，就应该为file菜单添加new这个动作
    同样对于工具栏，如果在工具栏中加入其他项则直接添加这个动作


再看action：
    action设置了绑定这个action的组件的图标，快捷键，还有状态栏的显示
    这么看的话action的作用也就明显了，以打开为例，一个桌面程序中会有很多中途径进行打开文件操作，比如菜单栏和工具栏，就像office
    但是通过不同的途径实际上执行的是同一个动作，也就是打开文件，所以只需要一个action就可以了
    然后就可以拥有同样的快捷键和状态栏显示这些
    在关于aboutMenuAndTool代码中可以看到，我们可以添加同一个项到不同的菜单和工具栏，通过对菜单栏和工具栏添加同样的action来实现
    但是，action不只是作为项用，本质上就像他的名字一样他是一个动作，在菜单栏里表现为Open按钮，点击即执行这个动作，发出信号并调用对这个信号有兴趣的对象的槽函数


对话框：
    对话窗口通常是一个顶层窗口，出现在程序最上层，用于实现短期任务或简洁的用户交互
    我们通常会设计一个类继承QDialog
    对于QDialog及其子类，如果其parent指针为NULL则这个窗口为一个顶层窗口，否则则作为其父组件的子对话框
    顶层窗口和非顶层窗口的区别在于，顶层窗口会有自己的位置而非顶层窗口和其夫组件共享位置
    对话框分为模态对话框和非模态对话框。
    所谓模态对话框，就是会阻塞同一应用程序中其它窗口的输入，例如打开文件功能
    Qt有应用级和窗口级两个级别的模态对话框，默认是应用级的
    应用级模态对话框会阻塞整个应用，而窗口级模态对话框则只阻塞与其关联的窗口
    Qt 使用QDialog::exec()实现应用程序级别的模态对话框，使用QDialog::open()实现窗口级别的模态对话框，使用QDialog::show()实现非模态对话框
    show函数不会阻塞进程，dialog是在栈上建立，所以show函数执行完毕程序继续执行里看看dialog的作用域，dialog被析构，窗口也就不存在了，所以一闪而过
    将dialog改为在堆上建立则窗口不会一闪而过，但是可以发现我们仍然能通过主窗口再打开一个dialog
    还有一个严重的问题就是，如果最堆上建立对话框对象，你会发现如同在示例中一样内存会泄露，但是如果你手动在函数的最后delete，窗口还会一闪而过
    但是如果你通过指定对话框的parent来解决这个问题，对象会在其父窗口结束的时候析构，在此之前即使你关掉了窗口也会继续占用内存
    所以示例里面通过加上dialog->setAttribute(Qt::WA_DeleteOnClose);来指定窗口关闭时的动作，即释放对象
    对于开始事件循环的应用级模态对话框，可以用QObject的deleteLater()函数在事件循环关闭时销毁对话框


对话框数据传递：
    对于使用事件循环显示的应用级模态对话框，我们可以在exec()函数后直接从对话框的对象获取数值
    exec()函数知道程序结束才会返回，也就是在程序结束的时候才能得到我们在控制台的输出
    QDialog::exec()是有返回值的，其返回值是QDialog::Accepted或者QDialog::Rejected
    exec()的返回值表示了用户点击了确定还是取消
    QDialog::show()函数会立即返回，如果我们也这么写，就不可能取得用户输入的数据，因为show返回之后实际上并没有结束这个窗口，用户也还没有输入
    所以对于非模态对话框，我们可以用信号槽机制，非模态对话框在关闭时可以调用QDialog::accept()或者QDialog::reject()或者更通用的QDialog::done()函数，所以我们可以在这里发出信号
    也就是重写一个accept函数为原本的accept加上一个发出信号的动作


QMessageBox:
    是Qt为我们提供的对话框，提供了几个基础而且常用的窗口，我们可以直接调用他来创建简单对话框
    但是QMessageBox只提供了几个简单的基础对话框，我们可以通过调用它的API来定制我们需要的窗口，就像示例中的保存窗口一样
    QMessageBox在不同的平台上，显示的窗口布局都不尽相同，也可以算是为了跨平台把蒽
    这里我们可以更清楚的看到，事件循环exec函数是有返回值的！


初看事件循环exec()：
    虽然还没开始看事件循环相关内容但是经常会用到事件循环，
    从使用中来看exec()开启了一个无线循环，保证了我们的窗口在我们窗口之前不会离开其作用域，但是，如果对于一个用堆创建的对象，也会带来一些内存问题
    因为事件循环不能让我们在窗口关闭时析构对象，如果通过设置窗口的父窗口来保证窗口析构，则在父窗口关闭之前会一直占用内存
    而且exec()函数是有返回值的，返回我们对窗口的操作，比如点击按钮之类
    同时exec()的阻塞了代码往下运行所以，只有在窗口关闭之后才会运行exec()之后的代码
    测试过程中还遇到一个问题，就是如果创建了一个QApplication并在主函数return a.exec()，但是没有创建窗口！这时测试输出正常输出但是程序一直没有结束！！！


Qt5信号槽语法：
    当信号被重载的时候，你的编译器无法确定你要连接的是哪个信号所以会报错
    这里可以改成qt4的写法或者创建函数指针来指定函数
    创建函数指针的时候可以用static_cast<>来避免类型转换的问题，当类型错误时他会给你报错
    槽函数可以比信号函数的参数少，因为实际上信号函数的参数是作为返回值用来传值的，如果槽函数的参数多则无法找到足够得参数
    有一种情况，槽函数的参数可以比信号的多，那就是槽函数的参数带有默认值
    当槽函数的参数有默认值是可以比信号函数参数多，因为信号函数不必提供那个参数，
    但是不能使用函数指针，参数默认值只能使用在直接地函数调用中。当使用函数指针取其地址的时候，默认参数是不可见的
    所以如果还不用qt4的写法的话，你需要使用lambda表达式来代替槽函数


文件对话框：
    本质上和之前的对话框都一样，不一样的是我将用文件对话框来实现保存，然后实现一个简单的文本编辑器
    写的过程中想到的问题：
        菜单栏和工具栏在创建的时候都没有指明他的父对象，那这个对象会在什么时候析构呢
        猜测由于action指定了父对象，使用这个action的组件会在action指定的父对象析构时被析构
        这里将文本编辑框作为了成员，那是应该尽可能将组件作为成员呢，还是说不需要在构造函数之外调用的组件尽可能不作为成员呢
        实现之后还有就是文本编码问题，这里的编码用的是Unicode编码所以，打开这个文件的话会出乱码，因为这个文本时utf-8的
    实现时候我们做出了一个简单的文本编辑程序但是，我们的程序中没有检查打开的是不是文本文件，当然微软会帮我们检查时限定只能搜索txt，起码在win10是这样的
    而且我们使用了QTextStream::readAll()直接读取文件所有内容，如果这个文件有 100M，程序会立刻死掉